<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>관리자 페이지 - 대구수학페스티벌</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>Δ</text></svg>">
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">Δ</div>
            <div>
                <h1>대구수학페스티벌</h1>
                <div class="subtitle">송현여자고등학교 Delta 부스 - 관리자</div>
            </div>
        </header>

        <div class="card">
            <h2>예약 관리</h2>
            <div class="description">체험 완료 및 보류 처리를 관리합니다</div>
        </div>

        <!-- 비밀번호 입력 모달 -->
        <div id="passwordModal" class="modal" style="display: block;">
            <div class="modal-content">
                <h3>관리자 인증</h3>
                <div class="form-group">
                    <label>비밀번호</label>
                    <input type="password" id="adminPassword" placeholder="비밀번호를 입력하세요" />
                </div>
                <button class="btn btn-primary" id="btnLogin">로그인</button>
                <div id="passwordError" class="text-small" style="color: var(--error-500); margin-top: var(--space-3); display: none;">
                    비밀번호가 올바르지 않습니다.
                </div>
            </div>
        </div>

        <div id="mainContent" style="display: none;">
            <div class="row">
                <div class="card">
                    <h3>비즈 키링</h3>
                    <div class="table-container">
                        <table class="table" id="table-keyring">
                            <thead>
                                <tr>
                                    <th>연락처</th>
                                    <th>인원</th>
                                    <th>상태</th>
                                    <th>작업</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>

                <div class="card">
                    <h3>비즈 마그넷</h3>
                    <div class="table-container">
                        <table class="table" id="table-magnet">
                            <thead>
                                <tr>
                                    <th>연락처</th>
                                    <th>인원</th>
                                    <th>상태</th>
                                    <th>작업</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
        import { getFirestore, collection, query, where, orderBy, getDocs, doc, updateDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';

        // Firebase 설정 (인라인으로 포함)
        const firebaseConfig = {
            apiKey: "AIzaSyA_YlXZRedGE4dHiIwZ40yc8GDaCoen0Pc",
            authDomain: "delta-3bf19.firebaseapp.com",
            projectId: "delta-3bf19",
            storageBucket: "delta-3bf19.firebasestorage.app",
            messagingSenderId: "975459775271",
            appId: "1:975459775271:web:87d105fecef201e2f96f02"
        };

        // Firebase 초기화
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const RES_COL = collection(db, 'reservations');

        const tbody = pid => document.querySelector(`#table-${pid} tbody`);
        let isAuthenticated = false;

        // 비밀번호 인증
        function authenticate(password) {
            return password === '0000';
        }

        // 로그인 처리
        document.getElementById('btnLogin').addEventListener('click', () => {
            const password = document.getElementById('adminPassword').value;
            const errorDiv = document.getElementById('passwordError');
            
            if (authenticate(password)) {
                isAuthenticated = true;
                document.getElementById('passwordModal').style.display = 'none';
                document.getElementById('mainContent').style.display = 'block';
                refreshAll(); // 데이터 로드 시작
                startAutoRefresh(); // 자동 새로고침 시작
            } else {
                errorDiv.style.display = 'block';
                document.getElementById('adminPassword').value = '';
                document.getElementById('adminPassword').focus();
            }
        });

        // Enter 키로 로그인
        document.getElementById('adminPassword').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('btnLogin').click();
            }
        });

        // 프로그램별 대기열 조회
        async function listProgramQueue(programId) {
            const q = query(
                RES_COL,
                where(`programs.${programId}.selected`, '==', true),
                orderBy(`programs.${programId}.enqueuedAt`, 'asc')
            );
            const snap = await getDocs(q);
            return snap.docs.map(d => ({ id: d.id, ...d.data() }));
        }

        // 상태 변경
        async function markStatus(docId, programId, status) {
            const ref = doc(db, 'reservations', docId);
            const payload = {};
            payload[`programs.${programId}.status`] = status; // 'done' | 'pending'
            if (status === 'pending') {
                // 보류 취소(되돌리기) 시, 뒤로 미루지 않고 상태만 복구
            }
            await updateDoc(ref, payload);
        }

        // 뒤로 미루기 (한 순서만 뒤로)
        async function bumpToBack(docId, programId) {
            try {
                // 현재 대기열 조회
                const queue = await listProgramQueue(programId);
                
                // 현재 항목 찾기
                const currentIndex = queue.findIndex(item => item.id === docId);
                if (currentIndex === -1) {
                    alert('현재 항목을 찾을 수 없습니다.');
                    return;
                }
                
                // 마지막 항목이면 그대로 유지
                if (currentIndex === queue.length - 1) {
                    alert('이미 마지막 순서입니다.');
                    return;
                }
                
                // 바로 뒤 항목의 시간 가져오기
                const nextItem = queue[currentIndex + 1];
                const nextTime = nextItem.programs[programId].enqueuedAt;
                
                // 뒤 항목보다 1초 늦은 시간으로 설정
                let newTime;
                if (nextTime && nextTime.toMillis) {
                    newTime = new Date(nextTime.toMillis() + 1000); // 1초 추가
                } else {
                    // 타임스탬프가 없는 경우 현재 시간 + 1초
                    newTime = new Date(Date.now() + 1000);
                }
                
                const ref = doc(db, 'reservations', docId);
                const payload = {};
                payload[`programs.${programId}.enqueuedAt`] = newTime;
                await updateDoc(ref, payload);
                
            } catch (error) {
                console.error('뒤로 미루기 중 오류 발생:', error);
                alert('뒤로 미루기 중 오류가 발생했습니다.');
            }
        }

        // 프로그램별 렌더링
        async function renderProgram(pid) {
            const rows = await listProgramQueue(pid);
            const html = rows.map(r => {
                const p = r.programs?.[pid];
                const isDone = p.status === 'done';
                return `
                    <tr>
                        <td class="${isDone ? 'strike' : ''}">${r.contact}</td>
                        <td class="${isDone ? 'strike' : ''}">${p.count}</td>
                        <td><span class="status-${p.status}">${p.status === 'pending' ? '대기중' : (p.status === 'done' ? '완료' : p.status)}</span></td>
                        <td>
                            <button class="btn btn-secondary" data-act="done" data-id="${r.id}" data-pid="${pid}">체험 완료</button>
                            <button class="btn btn-secondary" data-act="hold" data-id="${r.id}" data-pid="${pid}">한 순서 뒤로</button>
                            <button class="btn btn-secondary" data-act="undo" data-id="${r.id}" data-pid="${pid}">완료 취소</button>
                        </td>
                    </tr>
                `;
            }).join('');
            tbody(pid).innerHTML = html || '<tr><td colspan="4" class="small">대기열이 없습니다.</td></tr>';
        }

        // 전체 새로고침
        async function refreshAll() {
            await renderProgram('keyring');
            await renderProgram('magnet');
        }

        // 버튼 클릭 이벤트 처리
        document.body.addEventListener('click', async (e) => {
            const btn = e.target.closest('button[data-act]');
            if (!btn) return;
            
            // 인증 체크
            if (!isAuthenticated) {
                alert('관리자 인증이 필요합니다.');
                return;
            }
            
            const act = btn.dataset.act;
            const id = btn.dataset.id;
            const pid = btn.dataset.pid;
            
            if (act === 'done') {
                await markStatus(id, pid, 'done');
            } else if (act === 'undo') {
                await markStatus(id, pid, 'pending');
            } else if (act === 'hold') {
                await bumpToBack(id, pid);
            }
            
            await refreshAll();
        });

        // 주기적으로 새로고침 (5초) - 인증 후에만 시작
        let refreshInterval;
        
        function startAutoRefresh() {
            refreshInterval = setInterval(refreshAll, 5000);
        }
        
        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        }
    </script>
</body>
</html>